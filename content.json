{"meta":{"title":"Steve_braveman","subtitle":null,"description":null,"author":"Steve_braveman","url":"http://yoursite.com"},"pages":[{"title":"categories","date":"2018-08-16T09:08:44.548Z","updated":"2018-08-16T09:07:14.276Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"一些友链","date":"2018-08-17T07:31:35.000Z","updated":"2018-08-17T07:37:02.080Z","comments":true,"path":"link/index.html","permalink":"http://yoursite.com/link/index.html","excerpt":"","text":"同一届的dalao：dalao—-taborudalao中的dalao—ZUTTER神 · dalao——-WZX[AFO]另一个超级dalao——DEVILKdalao—Supergoodgame超级dalao—-shzr 外校大佬 Orz Orzalanyhq清风我已逝attackxzzKenlig 学长学姐们DieSheepCansultRefun ←—这个人是神"},{"title":"标签","date":"2018-08-17T06:35:07.118Z","updated":"2018-08-17T06:35:07.118Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"-其它-[置顶] 关于我","slug":"21","date":"2018-08-17T07:15:05.000Z","updated":"2018-08-17T07:38:25.069Z","comments":true,"path":"2018/08/17/21/","link":"","permalink":"http://yoursite.com/2018/08/17/21/","excerpt":"","text":"一个非常蒻的蒟蒻而已。 今年即将参加人生第一场NOIp。 1234unsigned long long NOIp2018_RP;while(1)&#123; NOIp2018_RP++;&#125;","categories":[],"tags":[{"name":"其它","slug":"其它","permalink":"http://yoursite.com/tags/其它/"}]},{"title":"-并查集- [BZOJ  4195][NOI 2015]程序自动分析","slug":"20","date":"2018-08-17T07:13:22.000Z","updated":"2018-08-17T07:16:46.945Z","comments":true,"path":"2018/08/17/20/","link":"","permalink":"http://yoursite.com/2018/08/17/20/","excerpt":"","text":"题目描述在实现程序自动分析的过程中，常常需要判定一些约束条件是否能被同时满足。 考虑一个约束满足问题的简化版本：假设x1,x2,x3…代表程序中出现的变量，给定n个形如xi=xj或xi≠xj的变量相等/不等的约束条件，请判定是否可以分别为每一个变量赋予恰当的值，使得上述所有约束条件同时被满足。例如，一个问题中的约束条件为：x1=x2,x2=x3,x3=x4,x4≠x1，这些约束条件显然是不可能同时被满足的，因此这个问题应判定为不可被满足。 现在给出一些约束满足问题，请分别对它们进行判定。 输入格式：输入文件的第1行包含1个正整数t，表示需要判定的问题个数。注意这些问题之间是相互独立的。 对于每个问题，包含若干行： 第1行包含1个正整数n，表示该问题中需要被满足的约束条件个数。接下来n行，每行包括3个整数i,j,e，描述1个相等/不等的约束条件，相邻整数之间用单个空格隔开。若e=1，则该约束条件为xi=xj；若e=0，则该约束条件为xi≠xj； 输出格式：输出文件包括t行。 输出文件的第 k行输出一个字符串“ YES” 或者“ NO”（不包含引号，字母全部大写），“ YES” 表示输入中的第k个问题判定为可以被满足，“ NO” 表示不可被满足。 样例输入221 2 11 2 021 2 12 1 1 样例输出NOYES 提示在第一个问题中，约束条件为：x1=x2,x1≠x2。这两个约束条件互相矛盾，因此不可被同时满足。 思路：这道题我们可以使用并查集来做，把相等的合并到一个集合里，如果出现不等判定一下是否在一个集合里； 注意：千万别用map，千万别用map，会超时，所以还是乖乖写离散化吧。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;#define MOD 10000019using namespace std;int m;struct node &#123; int x,y,e;&#125; bcj[MOD*2];int disa=0;bool cmp(node a,node b) &#123; return a.e&gt;b.e;&#125;int fa[200005];int find(int x) &#123; if(fa[x]!=x) return fa[x]=find(fa[x]); else return x;&#125;void un(int r1,int r2) &#123; fa[r1]=r2;&#125;int main() &#123; int t; cin&gt;&gt;t; for(int q=1; q&lt;=t; q++) &#123; disa=-1; bool flag=1; memset(ls,0,sizeof(ls)); memset(fa,0,sizeof(fa)); cin&gt;&gt;m; for(int i=1; i&lt;=m; i++) &#123; scanf(\"%d %d %d\",&amp;bcj[i].x,&amp;bcj[i].y,&amp;bcj[i].e); ls[disa++]=bcj[i].x; ls[disa++]=bcj[i].y; &#125; sort(ls,ls+disa); int x=unique(ls,ls+disa)-ls; for(int i=1; i&lt;=m; i++) &#123; bcj[i].x=lower_bound(ls,ls+x,bcj[i].x)-ls; bcj[i].y=lower_bound(ls,ls+x,bcj[i].y)-ls; &#125; for(int i=1; i&lt;=x; i++) &#123; fa[i]=i; &#125; sort(bcj+1,bcj+1+m,cmp); for(int i=1; i&lt;=m; i++) &#123; int g=find(bcj[i].x); int h=find(bcj[i].y); if(bcj[i].e) &#123; un(g,h); &#125; else &#123; if(g==h) &#123; printf(\"NO\\n\"); flag=0; break; &#125; else &#123; flag=1; &#125; &#125; &#125; if(flag) printf(\"YES\\n\"); &#125; return 0;&#125;","categories":[],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://yoursite.com/tags/BZOJ/"},{"name":"并查集","slug":"并查集","permalink":"http://yoursite.com/tags/并查集/"}]},{"title":"-最小生成树- [洛谷 P1546][USACO]最短网络","slug":"19","date":"2018-08-17T07:11:54.000Z","updated":"2018-08-17T07:14:38.688Z","comments":true,"path":"2018/08/17/19/","link":"","permalink":"http://yoursite.com/2018/08/17/19/","excerpt":"","text":"题目背景农民约翰被选为他们镇的镇长！他其中一个竞选承诺就是在镇上建立起互联网，并连接到所有的农场。当然，他需要你的帮助。 题目描述约翰已经给他的农场安排了一条高速的网络线路，他想把这条线路共享给其他农场。为了用最小的消费，他想铺设最短的光纤去连接所有的农场。 你将得到一份各农场之间连接费用的列表，你必须找出能连接所有农场并所用光纤最短的方案。每两个农场间的距离不会超过 $100000$ 。 输入格式：第一行： 农场的个数，$N（3&lt;=N&lt;=100）$。 第二行..结尾: 后来的行包含了一个$N \\time N$的矩阵,表示每个农场之间的距离。理论上，他们是N行，每行由N个用空格分隔的数组成，实际上，他们限制在$80$个字符，因此，某些行会紧接着另一些行。当然，对角线将会是$0$，因为不会有线路从第 $i$ 个农场到它本身。 输出格式：只有一个输出，其中包含连接到每个农场的光纤的最小长度。 输入样例：40 4 9 214 0 8 179 8 0 1621 17 16 0 输出样例：28 思路：这道题就是个最小生成树的模板题，但如果你用Kruskal，需要注意两点 1.数组一定要开大 2.手写cmp函数时一定要注意是a.w&lt;b.w千万别带等号，不然会T。。。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;typedef struct &#123; int u,v; int w;&#125; Edge;Edge e[2000002];int fa[2000002];bool cmp(const Edge &amp;a,const Edge &amp;b) &#123; if(a.w&lt;b.w) return true; else return false;&#125;int find(int n) &#123; if(fa[n]==0) return n; else return find(fa[n]);&#125;int uion(int r1,int r2) &#123; r1=find(r1); r2=find(r2); if(r1==r2) return 0; if(r1&lt;r2) fa[r2]=r1; else fa[r1]=r2; return 1;&#125;int main() &#123; int n,p; int sum,count; cin&gt;&gt;n; int k=1; for(int i=1; i&lt;=n; i++) &#123; for(int j=1; j&lt;=n; j++) &#123; int x; scanf(\"%d\",&amp;x); if(j&gt;i) &#123; e[k].w=x; e[k].u=i; e[k].v=j; k++; &#125; &#125; &#125; k--; sort(e+1,e+1+k,cmp); memset(fa,0,sizeof(fa)); sum=0; count=1; for(int i=1; i&lt;=k; i++) &#123; if(uion(e[i].u,e[i].v)) &#123; sum+=e[i].w; count++; &#125; if(count==n) break; &#125; printf(\"%d\",sum); return 0;&#125;","categories":[],"tags":[{"name":"最小生成树","slug":"最小生成树","permalink":"http://yoursite.com/tags/最小生成树/"},{"name":"洛谷","slug":"洛谷","permalink":"http://yoursite.com/tags/洛谷/"}]},{"title":"-DP- [洛谷 P1091][NOIp 2004]合唱队形","slug":"18","date":"2018-08-17T07:10:12.000Z","updated":"2018-08-17T07:11:32.158Z","comments":true,"path":"2018/08/17/18/","link":"","permalink":"http://yoursite.com/2018/08/17/18/","excerpt":"","text":"题目描述$N$ 位同学站成一排，音乐老师要请其中的( $N−K$ )位同学出列，使得剩下的 $K$ 位同学排成合唱队形。合唱队形是指这样的一种队形：设K位同学从左到右依次编号为 $1,2,…,K$ ，他们的身高分别为 $T_1,T_2,…,T_K$ ， 则他们的身高满足 $T_1&lt;…T_{i+1}&gt;…&gt;T_K(1 \\le i \\le K)$ 。你的任务是，已知所有$N$位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。 输入格式：共二行。第一行是一个整数 $N(2 \\le N \\le 100)$ ，表示同学的总数。第二行有 $n$ 个整数，用空格分隔，第 $i$ 个整数 $T_i(130 \\le T_i \\le 230)$ 是第 $i$ 位同学的身高（厘米）。 输出格式：一个整数，最少需要几位同学出列。 输入样例：8186 186 150 200 160 130 197 220 输出样例：4 思路：首先分析一下题目，题目的意思是找出几个人排成一个先单调递增后单调递减的队伍； 所以我们可以这样求：先枚举到第 $i$ 个人然后求出第 $i$ 个人前的最长上升子序列，再求出第 $i$ 个人后最长下降子序列。 注：需要特判一下当出现只单调递增或只单调递减的情况。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int max(int a,int b) &#123; return (a&gt;=b)?a:b;&#125;int main() &#123; int a[105],ans=0; int n; cin&gt;&gt;n; for(int i=0; i&lt;n; i++) &#123; cin&gt;&gt;a[i]; &#125; bool flag=1; for(int i=0; i&lt;n; i++) &#123; if(a[i]&lt;=a[i-1]) &#123; flag=0; &#125; &#125; if(flag)&#123; cout&lt;&lt;'0'&lt;&lt;endl; return 0; &#125; for(int i=0;i&lt;n;i++)&#123; if(a[i]&gt;=a[i-1]) &#123; flag=0; &#125; &#125; if(flag)&#123; cout&lt;&lt;'0'&lt;&lt;endl; return 0; &#125; int b[105],c[105]; int maxn=0; for(int k=0; k&lt;n; k++) &#123; memset(b,0,sizeof(b)); memset(c,0,sizeof(c)); c[0]=1; b[0]=1; for (int i=1; i&lt;k; i++) &#123; b[i] = 1; for (int j=0; j&lt;i; j++) &#123; if (a[i]&gt;a[j]&amp;&amp;b[j]+1&gt;b[i]) b[i]=b[j]+1; &#125; &#125; for (int i=k+1; i&lt;n; i++) &#123; c[i] = 1; for (int j=k; j&lt;i; j++) &#123; if (a[i]&lt;a[j]&amp;&amp;c[j]+1&gt;c[i]) c[i]=c[j]+1; &#125; &#125; int maxb=0,maxc=0; for (int i=0; i&lt;k; i++) &#123; maxb=max(b[i],maxb); &#125; for (int i=k; i&lt;n; i++) &#123; maxc=max(c[i],maxc); &#125; maxn=max(maxn,maxb+maxc); &#125; cout&lt;&lt;n-maxn&lt;&lt;endl; return 0;&#125;","categories":[],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"http://yoursite.com/tags/洛谷/"},{"name":"DP","slug":"DP","permalink":"http://yoursite.com/tags/DP/"}]},{"title":"-队列- [洛谷 P1540][NOIp 2010]机器翻译","slug":"17","date":"2018-08-17T07:07:54.000Z","updated":"2018-08-17T07:09:15.152Z","comments":true,"path":"2018/08/17/17/","link":"","permalink":"http://yoursite.com/2018/08/17/17/","excerpt":"","text":"题目背景小晨的电脑上安装了一个机器翻译软件，他经常用这个软件来翻译英语文章。 题目描述这个翻译软件的原理很简单，它只是从头到尾，依次将每个英文单词用对应的中文含义来替换。对于每个英文单词，软件会先在内存中查找这个单词的中文含义，如果内存中有，软件就会用它进行翻译；如果内存中没有，软件就会在外存中的词典内查找，查出单词的中文含义然后翻译，并将这个单词和译义放入内存，以备后续的查找和翻译。假设内存中有 $M$ 个单元，每单元能存放一个单词和译义。每当软件将一个新单词存入内存前，如果当前内存中已存入的单词数不超过 $M-1$ ，软件会将新单词存入一个未使用的内存单元；若内存中已存入 $M$ 个单词，软件会清空最早进入内存的那个单词，腾出单元来，存放新单词。假设一篇英语文章的长度为 $N$ 个单词。给定这篇待译文章，翻译软件需要去外存查找多少次词典？假设在翻译开始前，内存中没有任何单词。 输入格式：共 $2$ 行。每行中两个数之间用一个空格隔开。第一行为两个正整数 $M,N$ ，代表内存容量和文章的长度。第二行为 $N$ 个非负整数，按照文章的顺序，每个数（大小不超过 $1000$ ）代表一个英文单词。文章中两个单词是同一个单词，当且仅当它们对应的非负整数相同。 输出格式：一个整数，为软件需要查词典的次数。 输入样例：3 71 2 1 5 4 4 1 输出样例：5 说明：每个测试点 $1s$对于 $10%$ 的数据有 $M=1,N≤5$ 。对于 $100%$ 的数据有$ 0≤M≤100,0≤N≤10000$ 。整个查字典过程如下：每行表示一个单词的翻译，冒号前为本次翻译后的内存状况：空：内存初始状态为空。1． $1$ ：查找单词$1$并调入内存。2． $1 2$ ：查找单词 $2$ 并调入内存。3． $1 2$ ：在内存中找到单词 $1$ 。4． $1 2 5$ ：查找单词 $5$ 并调入内存。5． $2 5 4$ ：查找单词 $4$ 并调入内存替代单词 $1$ 。6． $2 5 4$ ：在内存中找到单词 $4$ 。7． $5 4 1$ ：查找单词1并调入内存替代单词 $2$ 。共计查了 55 次词典。 没什么说的，就是队列模板题。 _注意：千万不要把查找和找到搞混了！_ 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int n,m;int q[1005]=&#123;0&#125;;int chk=0;int head=1,tail=0;int main()&#123; cin&gt;&gt;m&gt;&gt;n;// for(int i=1;i&lt;=n;i++)&#123;// q[i]=-1// &#125; if(n==0||m==0)&#123; return 0; &#125; for(int i=1;i&lt;=n;i++)&#123; int x; cin&gt;&gt;x; bool flag=0; for(int j=head;j&lt;=tail;j++)&#123; if(q[j]==x)&#123; flag=1;// printf(\"Find %d\\n\",x); break; &#125; &#125; if(flag)&#123; continue; &#125; if(tail-head+1==m)&#123; head++; tail++; chk++;// printf(\"Add %d\\n\",x); q[tail]=x; &#125; else&#123; tail++; chk++;// printf(\"Add %d\\n\",x); q[tail]=x; &#125; &#125; cout&lt;&lt;chk&lt;&lt;endl; return 0;&#125;","categories":[],"tags":[{"name":"队列","slug":"队列","permalink":"http://yoursite.com/tags/队列/"},{"name":"洛谷","slug":"洛谷","permalink":"http://yoursite.com/tags/洛谷/"}]},{"title":"-最小生成树- [BZOJ 1083][SCOI 2005]繁忙的都市","slug":"15-1","date":"2018-08-17T07:05:26.000Z","updated":"2018-08-17T07:07:21.184Z","comments":true,"path":"2018/08/17/15-1/","link":"","permalink":"http://yoursite.com/2018/08/17/15-1/","excerpt":"","text":"题目描述城市C是一个非常繁忙的大都市，城市中的道路十分的拥挤，于是市长决定对其中的道路进行改造。城市C的道路是这样分布的：城市中有$n$个交叉路口，有些交叉路口之间有道路相连，两个交叉路口之间最多有一条道路相连接。这些道路是双向的，且把所有的交叉路口直接或间接的连接起来了。每条道路都有一个分值，分值越小表示这个道路越繁忙，越需要进行改造。但是市政府的资金有限，市长希望进行改造的道路越少越好，于是他提出下面的要求： 1． 改造的那些道路能够把所有的交叉路口直接或间接的连通起来。 2． 在满足要求1的情况下，改造的道路尽量少。 3． 在满足要求1、2的情况下，改造的那些道路中分值最大的道路分值尽量小。任务：作为市规划局的你，应当作出最佳的决策，选择那些道路应当被修建。 输入格式第一行有两个整数$n$,$m$表示城市有$n$个交叉路口，$m$条道路。接下来$m$行是对每条道路的描述，$u$，$v$，$c$表示交叉路口$u$和$v$之间有道路相连，分值为$c$。$(1≤n≤300，1≤c≤10000)$ 输出样例两个整数$s$，$max$，表示你选出了几条道路，分值最大的那条道路的分值是多少。 样例输入4 51 2 31 4 52 4 72 3 63 4 8 样例输出3 6 首先让我们看看要求： 1． 改造的那些道路能够把所有的交叉路口直接或间接的连通起来。 2． 在满足要求1的情况下，改造的道路尽量少。 3． 在满足要求1、2的情况下，改造的那些道路中分值最大的道路分值尽量小。任务：作为市规划局的你，应当作出最佳的决策，选择那些道路应当被修建。 分析完之后，我们可以发现，这就是一道最小生成树的模板题。 由于我比较喜欢使用Kruskal，所以我写的是kruskal代码； 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;struct edge&#123; int u, v; int w;&#125; ;edge e[200002];int fa[200002];bool cmp(edge a, edge b) &#123; if (a.w&lt;b.w) return 1; else return 0;&#125;int find(int n) &#123; if (fa[n] == 0) return n; else return find(fa[n]);&#125;int max(int a, int b) &#123; return a &gt; b ? a : b;&#125;bool un(int a, int b) &#123; a = find(a); b = find(b); if (a == b) return 0; if (a&lt;b) fa[b] = a; else fa[a] = b; return 1;&#125;int main() &#123; int n, p; int sum, ct;// scanf(\"%d%d\", &amp;n, &amp;p); cin &gt;&gt; n &gt;&gt; p; for (int i = 1; i &lt;= p; i++) &#123;// scanf(\"%d%d%d\", &amp;e[i].u, &amp;e[i].v, &amp;e[i].w); cin &gt;&gt; e[i].u &gt;&gt; e[i].v &gt;&gt; e[i].w; &#125; sort(e + 1, e + 1 + p, cmp); memset(fa, 0, sizeof(fa)); sum = 0; ct = 1; int tot = 0; int maxa = 0; for (int i = 1; i &lt;= p; i++) &#123; if (un(e[i].u, e[i].v)) &#123;// sum += e[i].w; tot++; maxa = max(maxa,e[i].w); ct++; &#125; if (ct == n) break; &#125; printf(\"%d %d\", tot,maxa); return 0;&#125;","categories":[],"tags":[{"name":"最小生成树","slug":"最小生成树","permalink":"http://yoursite.com/tags/最小生成树/"},{"name":"BZOJ","slug":"BZOJ","permalink":"http://yoursite.com/tags/BZOJ/"}]},{"title":"-DP-递推- [洛谷 P1006][NOIp 2008]传纸条","slug":"15","date":"2018-08-17T07:02:40.000Z","updated":"2018-08-17T07:07:19.743Z","comments":true,"path":"2018/08/17/15/","link":"","permalink":"http://yoursite.com/2018/08/17/15/","excerpt":"","text":"题目描述小渊和小轩是好朋友也是同班同学，他们在一起总有谈不完的话题。一次素质拓展活动中，班上同学安排做成一个 $m$ 行 $n$ 列的矩阵，而小渊和小轩被安排在矩阵对角线的两端，因此，他们就无法直接交谈了。幸运的是，他们可以通过传纸条来进行交流。纸条要经由许多同学传到对方手里，小渊坐在矩阵的左上角，坐标 $(1,1)$，小轩坐在矩阵的右下角，坐标 $(m,n)$ 。从小渊传到小轩的纸条只可以向下或者向右传递，从小轩传给小渊的纸条只可以向上或者向左传递。 在活动进行中，小渊希望给小轩传递一张纸条，同时希望小轩给他回复。班里每个同学都可以帮他们传递，但只会帮他们一次，也就是说如果此人在小渊递给小轩纸条的时候帮忙，那么在小轩递给小渊的时候就不会再帮忙。反之亦然。 还有一件事情需要注意，全班每个同学愿意帮忙的好感度有高有低（注意：小渊和小轩的好心程度没有定义，输入时用 $0$ 表示），可以用一个 $0−100$ 的自然数来表示，数越大表示越好心。小渊和小轩希望尽可能找好心程度高的同学来帮忙传纸条，即找到来回两条传递路径，使得这 $2$ 条路径上同学的好心程度之和最大。现在，请你帮助小渊和小轩找到这样的 $2$ 条路径。 输入格式：输入文件，第一行有 $2$ 个用空格隔开的整数 $m$ 和 $n$ ，表示班里有 $m$ 行 $n$ 列。 接下来的 $m$ 行是一个 $m \\times n$ 的矩阵，矩阵中第 $i$ 行 $j$ 列的整数表示坐在第 $i$ 行 $j$ 列的学生的好心程度。每行的 $n$ 个整数之间用空格隔开。 输出格式：输出文件共一行，包含一个整数，表示来回 $2$ 条路上参与传递纸条的学生的好心程度之和的最大值。 输入样例3 30 3 92 8 55 7 0 输出样例34 首先让我们把问题转化一下，小渊给小轩传纸条，小轩也要给小渊传纸条，而且路径不能一样，其实就是相当于 _小渊选择两个不同的路径，给小轩传两张纸条_ 。所以让我们来开一个四维数组f[i][j][p][q]，表示两张纸条传到$(i,j)$，$(p,q)$的最大总价值。一张处于$(i,j)$的纸条一定是从$(i-1,j)$或$(i,j-1)$传过来，因为要最大，所以$f[i][j]=max(f[i-1][j],f[i][j-1])$。于是我们可以写一个四重循环，时间复杂度为$O(n^4)$。但是有一个地方需要注意！当$i=p$，$j=q$时，一定要特殊处理一下，不然就会出错。代吗：1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;using namespace std;int max(int a,int b)&#123;\\\\手写max函数 return a&gt;b?a:b;&#125;int mp[50][50]=&#123;0&#125;;int f[52][52][52][52]=&#123;0&#125;;int main()&#123; int n,v,m; cin&gt;&gt;m&gt;&gt;n; for(int i=1;i&lt;=m;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; cin&gt;&gt;v; mp[i][j]=v; &#125; &#125; for(int i=1;i&lt;=m;i++)&#123;//下面开始四重循环 for(int j=1;j&lt;=n;j++)&#123; for(int p=1;p&lt;=m;p++)&#123; for(int q=1;q&lt;=n;q++)&#123; f[i][j][p][q]=max(max(f[i-1][j][p-1][q],f[i][j-1][p-1][q]),max(f[i-1][j][p][q-1],f[i][j-1][p][q-1]))+mp[i][j]+mp[p][q]; if(i==p&amp;&amp;j==q) f[i][j][p][q]-=mp[p][q];//特殊处理，不然会多加 &#125; &#125; &#125; &#125; cout&lt;&lt;f[m][n][m][n]&lt;&lt;endl; return 0;//完美结束&#125; 顺便说一句，如果你这道题A了，那么P1004也就能A了，并且P1004(方格取数)的数据还比P1006弱。。。。。。","categories":[],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"http://yoursite.com/tags/洛谷/"},{"name":"DP","slug":"DP","permalink":"http://yoursite.com/tags/DP/"},{"name":"递推","slug":"递推","permalink":"http://yoursite.com/tags/递推/"}]},{"title":"-奇技淫巧- C++ 手动开O2优化","slug":"14","date":"2018-08-17T07:01:34.000Z","updated":"2018-08-17T07:04:48.354Z","comments":true,"path":"2018/08/17/14/","link":"","permalink":"http://yoursite.com/2018/08/17/14/","excerpt":"","text":"觉得自己的程序耗时太长？ 费尽心思也卡不进那要命的时限？ 那就来这个吧，大幅度提升程序速度！ 手动开启O2优化！ 1#pragma GCC optimize(2) PS：在一些特殊情况下O2会起到反作用，会使能AC的程序RE。。。。。 PS2：NOIp禁止使用O2及其他类似优化，会禁赛，不过NOI允许开。","categories":[],"tags":[{"name":"奇技淫巧","slug":"奇技淫巧","permalink":"http://yoursite.com/tags/奇技淫巧/"}]},{"title":"-奇技淫巧- C++ 读入输出优化","slug":"13","date":"2018-08-17T06:59:29.000Z","updated":"2018-08-17T07:04:39.763Z","comments":true,"path":"2018/08/17/13/","link":"","permalink":"http://yoursite.com/2018/08/17/13/","excerpt":"","text":"有一种比scanf和printf更快的输入输出，那就是读入输出优化！ 快读模板：1234567void read(int &amp;x)&#123; int f=1,x=0;char s=getchar(); while(s&lt;'0'||s&gt;'9')&#123;if(s=='-')f=-1;s=getchar();&#125; while(s&gt;='0'&amp;&amp;s&lt;='9')&#123;x=x*10+s-'0';s=getchar();&#125; x*=f;&#125; 快速输出模板： 1234567891011void write(int x)&#123; if(x&lt;0) &#123; putchar('-'); x=-x; &#125; if(x&gt;9) write(x/10); putchar(x%10+'0');&#125; 当输入输出的数据非常非常多时，就可用这个！ 当然如果你懒得手敲读入输出优化代码，还是用scanf和printf吧","categories":[],"tags":[{"name":"奇技淫巧","slug":"奇技淫巧","permalink":"http://yoursite.com/tags/奇技淫巧/"}]},{"title":"-DFS-[CodeVS P3880]环素数","slug":"blog12","date":"2018-08-17T06:47:25.000Z","updated":"2018-08-17T07:38:30.914Z","comments":true,"path":"2018/08/17/blog12/","link":"","permalink":"http://yoursite.com/2018/08/17/blog12/","excerpt":"","text":"题目描述给定一个N(1&lt;=N&lt;=10)，求1——N组成的环，使得环上相邻的元素和为素数。 输入描述一个整数N 输出描述把1放在第一位置，按照字典顺序不重复地输出所有解（顺时针，逆时针算不同的两种），相邻两数之间严格用一个空格隔开，每一行的末尾不能有多余的空格。如果无解，则输出“no”。 样例输入8 样例输出1 2 3 8 5 6 7 41 2 5 8 3 4 7 61 4 7 6 5 8 3 21 6 7 4 3 8 5 2 思路：运用DFS，代码中会详细解释。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstdlib&gt;using namespace std;int n,a[15]= &#123;0&#125;;bool used[15]= &#123;0&#125;,flag=0;bool chk_prime(int a) &#123;//用于判断素数的函数 if(a==2) return 1; if(a==1) return 0; if(a==0) return 0; for(int i=2; i&lt;=sqrt(a); i++) &#123; if(a%i==0) return 0; &#125; return 1;&#125;bool chk() &#123;//用于判断是否符合条件的函数 int p=0; for(int i=1; i&lt;=n-1; i++) &#123; if(chk_prime(a[i]+a[i+1])==1) &#123; p++; &#125; &#125; if(chk_prime(a[n]+a[1])==1) p++; if(p==n) return 1; else return 0;&#125;void print() &#123;//用于打印的函数 for(int i=1; i&lt;=n-1; i++) &#123; printf(\"%d \",a[i]); &#125; printf(\"%d\\n\",a[n]); flag=1;//标记存在答案&#125;void dfs(int i) &#123;//进行深度优先搜索(DFS)// print(); for(int j=2; j&lt;=n; j++) &#123; if(used[j]==0) &#123;//如果这个数没用过 a[i]=j;//那就使用这个数 used[j]=1;//把这个数标记为用过 if(i==n) &#123; if(chk()==1) &#123; print();//打印答案 &#125; &#125; else dfs(i+1); /*回溯部分*/ used[j]=0; a[i]=0; &#125; &#125;&#125;int main() &#123; cin&gt;&gt;n; a[1]=1; used[1]=1; dfs(2);//进行DFS if(flag==0)&#123;//如果没有答案，就输出no cout&lt;&lt;\"no\"; &#125; return 0;//程序结束&#125;","categories":[],"tags":[{"name":"DFS","slug":"DFS","permalink":"http://yoursite.com/tags/DFS/"},{"name":"CodeVS","slug":"CodeVS","permalink":"http://yoursite.com/tags/CodeVS/"}]},{"title":"-其它-几种常见排序","slug":"blog11g","date":"2018-08-17T06:39:18.000Z","updated":"2018-08-17T06:57:19.997Z","comments":true,"path":"2018/08/17/blog11g/","link":"","permalink":"http://yoursite.com/2018/08/17/blog11g/","excerpt":"","text":"冒泡排序冒泡排序的原理总的来说就是小的浮上来，大的沉底。 思路：如果$a_i &lt; a_{i+1}$，则交换。 原理示意图： 冒泡排序的平均情况时间复杂度为$O(n^2)$。 代码如下： 1234567891011121314void Bubble_Sort(int a[],int length) &#123; for(int i=1; i&lt;=n-1; i++) &#123; int m=1; for(int j=1; j&lt;=n-i; j++) &#123; if(a[j]&gt;a[j+1]) &#123; m=0; temp=a[j]; a[j]=a[j+1]; a[j+1]=temp; &#125; &#125; if(m==1) break; &#125;&#125; 快速排序快排的思路是：先选取一个基准，然后将比基准小的放在左边，将比基准大的放在右边，然后再分小区间，重复以上操作。 原理示意图： 快速排序的平均情况时间复杂度为$O(n\\log_2 n)$。 代码： 1234567891011121314151617181920void Quick_Sort(int s[], int l, int r) &#123; if(l&lt;r) &#123; int low=l; int high=r; int pivot = s[l]; while(low&lt;high) &#123; while(low&lt;high&amp;&amp;s[high]&gt;= pivot) high--; if(low&lt;high) s[low++] = s[high]; while(low&lt;high&amp;&amp;s[low]&lt;pivot) low++; if(low&lt;high) s[high--] = s[low]; &#125; s[low]=pivot; QuickSort(s, l, low - 1); QuickSort(s, low + 1, r); &#125;&#125; 插入排序首先回忆一下你是怎么玩牌的，每次摸到一张牌，都要把它插入到正确位置。 插入排序的原理一样，首先查找一下它的正确位置$a_i$，然后将$a_i$后数向后移动一位，将这个数插入进去。 原理示意图： 插入排序的平均情况时间复杂度是$O(n^2)$。 代码： 1234567891011121314void Insertion_Sort(int arr[],int length) &#123; int i,j,key; for(i=0; i&lt;length; i++) &#123; key=arr[i]; for(j=i-1; j&gt;=0; j--) &#123; if (arr[j]&gt;key) &#123; arr[j+1]=arr[j]; &#125; else &#123; break; &#125; &#125; arr[j+1]=key; &#125;&#125; 选择排序选择排序原理：首先找出最小值，然后放在数列的最前面，如此反复。 原理示意图： 选择排序的平均情况时间复杂度为$O(n^2)$。 代码如下 12345678910111213void Selection_Sort(int a[],int length)&#123; for(int i=0;i&lt;n;i++)&#123; int k=i; for(int j=i;j&lt;n;j++)&#123; if(a[j]&lt;a[k])&#123; k=j; &#125; &#125; int t=a[i]; a[i]=a[k]; a[k]=t; &#125;&#125; 桶排序设一个数组为桶，数组的大小为待排序数列的最大值加1，桶号即为数列的每一个值，当出现这个数时，对应的桶就加1。 原理示意图： 桶排序的平均情况时间复杂度为$O(n)$，但空间复杂度为$O(n)$。 代码：123456789101112131415void Bucket_Sort(int a[], int max, int length) &#123; int B[max+1]= &#123;0&#125;; int i,j,count=0; for (i=0; i&lt;length; i++) &#123; B[a[i]]+=1; &#125; for(i=0; i&lt;=max; i++) &#123; if (B[i]&gt;0) &#123; for(j=0; j&lt;B[i]; j++) &#123; a[count]=i; count++; &#125; &#125; &#125;&#125; 终极の排序不需要任何算法，直接一个函数搞定！ 1sort(a+1,a+1+n) 别忘了加这个头文件：1#include&lt;algorithm&gt; 还可以通过写一个函数来决定从大到小排还是从小到大排。 PS:不知道因为什么原因图挂了。。。。我会修复的","categories":[],"tags":[{"name":"其它","slug":"其它","permalink":"http://yoursite.com/tags/其它/"}]},{"title":"-递推-[洛谷 P1096][NOIp 2007]Hanoi双塔问题","slug":"bog10","date":"2018-08-17T06:38:53.000Z","updated":"2018-08-17T06:52:12.237Z","comments":true,"path":"2018/08/17/bog10/","link":"","permalink":"http://yoursite.com/2018/08/17/bog10/","excerpt":"","text":"描述给定$A、B、C$三根足够长的细柱，在$A$柱上放有$2n$个中间有孔的圆盘，共有$n$个不同的尺寸，每个尺寸都有两个相同的圆盘，注意这两个圆盘是不加区分的。 现要将这些圆盘移到$C$柱上，在移动过程中可放在$B$柱上暂存。要求：（1）每次只能移动一个圆盘；（2）$A$、$B$、$C$三根细柱上的圆盘都要保持上小下大的顺序；任务：设$A_n$为$2_n$个圆盘完成上述任务所需的最少移动次数，对于输入的$n$，输出$A_n$。 输入格式：一个正整数$n$，表示在$A$柱上放有$2n$个圆盘。输出格式： 一个正整数, 为完成上述任务所需的最少移动次数$A_n$。 样例输入：2 样例输入：6 算法分析首先我们知道如果是单个盘子，设$n$个盘子所需步数为$F(n)$ 则$F(n)=2*F(n-1)+1$ 然而这道题是双盘，所以相当于把单盘移动次数乘2。 我们可以得出单盘的通项公式为$2^p-1$； 所以双盘的通项公式为$2^{p+1}-2$ 这道题数据范围贼大，所以我们需要高精度 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//Hanoi双塔问题.cpp#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int a[100010];int main()&#123; int n; cin&gt;&gt;n; int j=1; int k=1; memset(a,-1,sizeof(a)); a[1]=1; for(int i=1;i&lt;=n+1;i++)&#123; while(a[j]&gt;=0)&#123; a[j]*=2; j++; &#125; while(a[k]&gt;=0)&#123; if(a[k]&gt;=10)&#123; a[k]%=10; if(a[k+1]&lt;0)&#123; a[k+1]=0; a[k+1]++; break; &#125; else&#123; a[k+1]++; &#125; &#125; k++; &#125; j=1;k=1; &#125; int y=0; a[1]-=2; for(int i=1;i&lt;=100000;i++)&#123; if(a[i]&gt;=0)&#123; y++; &#125; &#125; for(int i=y;i&gt;=1;i--)&#123; cout&lt;&lt;a[i]; &#125;&#125;代码","categories":[],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"http://yoursite.com/tags/洛谷/"},{"name":"递推","slug":"递推","permalink":"http://yoursite.com/tags/递推/"}]},{"title":"-DFS-[洛谷 P1025][NOIp 2001]数的划分","slug":"blog9","date":"2018-08-17T06:38:36.000Z","updated":"2018-08-17T06:52:10.441Z","comments":true,"path":"2018/08/17/blog9/","link":"","permalink":"http://yoursite.com/2018/08/17/blog9/","excerpt":"","text":"题目描述将整数 $n$ 分成$k$份，且每份不能为空，任意两个方案不相同(不考虑顺序)。 例如： $n=7$ ， $k=3$ ，下面三种分法被认为是相同的。 $1,1,5$;$1,5,1$;$5,1,1$; 问有多少种不同的分法。 输入格式$n$,$k$ $(6&lt;n≤200,2≤k≤6)$ 输出格式：$1$ 个整数，即不同的分法。 输入样例7 3 输出样例4 这道题十分简单，就是裸的DFS，代码也只有十多行，不过需要一个小小的剪枝。123456789101112131415161718#include&lt;bits/stdc++.h&gt;using namespace std;int a[10001]=&#123;1&#125;,n,tot,k;void dfs(int,int,int);int main()&#123; cin&gt;&gt;n&gt;&gt;k; dfs(1,0,0); cout&lt;&lt;tot;&#125;void dfs(int s,int t,int p)&#123;//一共三个参数，分别是：当前拆分出来的数、数的总和、分的第几份 if(p==k)&#123; if(t==n) tot++; return; &#125; for(int i=s;t+i*(k-p)&lt;=n;i++)&#123;//剪枝 dfs(i,t+i,p+1); &#125;&#125;","categories":[],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"http://yoursite.com/tags/洛谷/"},{"name":"DFS","slug":"DFS","permalink":"http://yoursite.com/tags/DFS/"}]},{"title":"-其它- A+B|A-B|A*B Problem","slug":"blog8","date":"2018-08-17T06:35:43.000Z","updated":"2018-08-17T06:52:09.773Z","comments":true,"path":"2018/08/17/blog8/","link":"","permalink":"http://yoursite.com/2018/08/17/blog8/","excerpt":"","text":"当long long不够用时，就得用高精度了！ 高精度加法123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;char a1[500001],b1[500001];int a[500001],b[500001],c[500001],x,lenc,la,lb,i;int main()&#123; memset(a,0,sizeof(a)); memset(b,0,sizeof(b)); memset(c,0,sizeof(c)); gets(a1); gets(b1); la=strlen(a1); lb=strlen(b1); for(i=0;i&lt;=la-1;i++)&#123; a[la-i]=a1[i]-'0'; &#125; for(i=0;i&lt;=lb-1;i++)&#123; b[lb-i]=b1[i]-'0'; &#125; lenc=1; x=0; while(lenc&lt;=la||lenc&lt;=lb)&#123; c[lenc]=a[lenc]+b[lenc]+x; x=c[lenc]/10; c[lenc]%=10; lenc++; &#125; c[lenc]=x; if(c[lenc]==0) lenc--; for(i=lenc;i&gt;=1;i--) cout&lt;&lt;int(c[i]); return 0;&#125; 高精度减法12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;using namespace std;int main()&#123; int a[10001],b[10001],c[10001],la,lb,lc,i; char n[10001],n1[10001],n2[10001]; memset(a,0,sizeof(a)); memset(b,0,sizeof(b)); memset(c,0,sizeof(c)); cin&gt;&gt;n1&gt;&gt;n2; if(strlen(n1)&lt;strlen(n2)||(strlen(n1)==strlen(n2)&amp;&amp;strcmp(n1,n2)&lt;0))&#123; strcpy(n,n1); strcpy(n1,n2); strcpy(n2,n); cout&lt;&lt;\"-\"; &#125; la=strlen(n1); lb=strlen(n2); for(i=0;i&lt;=la-1;i++)&#123; a[la-i]=int(n1[i]-'0'); &#125; for(i=0;i&lt;=lb-1;i++)&#123; b[lb-i]=int(n2[i]-'0'); &#125; i=1; while(i&lt;=la||i&lt;=lb)&#123; if(a[i]&lt;b[i])&#123; a[i]+=10; a[i+1]--; &#125; c[i]=a[i]-b[i]; i++; &#125; lc=i; while((c[lc]==0)&amp;&amp;(lc&gt;1)) lc--; for(i=lc;i&gt;=1;i--) cout&lt;&lt;c[i]; cout&lt;&lt;endl; return 0;&#125; 高精度乘法123456789101112131415161718192021222324252627282930313233343536373839404142//A*B problem.cpp#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;char a1[2006],b1[2006];int a[2006]=&#123;0&#125;,b[2006]=&#123;0&#125;,c[20000050]=&#123;0&#125;,lena,lenb,lenc,i,j,x;int main()&#123; memset(a,0,sizeof(a)); memset(b,0,sizeof(b)); memset(c,0,sizeof(c)); scanf(\"%s\",a1); scanf(\"%s\",b1); lena=strlen(a1); lenb=strlen(b1); for(i=0;i&lt;lena;i++)&#123; a[lena-i]=a1[i]-'0'; &#125; for(i=0;i&lt;lenb;i++)&#123; b[lenb-i]=b1[i]-'0'; &#125; for(i=1;i&lt;=lena;i++)&#123; x=0; for(j=1;j&lt;=lenb;j++)&#123; c[i+j-1]=a[i]*b[j]+x+c[i+j-1]; x=c[i+j-1]/10; c[i+j-1]%=10; &#125; c[i+lenb]=x; &#125; lenc=lena+lenb; while(c[lenc]==0&amp;&amp;lenc&gt;1)&#123; lenc--; &#125; for(i=lenc;i&gt;=1;i--)&#123; cout&lt;&lt;c[i]; &#125; cout&lt;&lt;endl; return 0;&#125;A*B Problem","categories":[],"tags":[{"name":"其它","slug":"其它","permalink":"http://yoursite.com/tags/其它/"}]},{"title":"-贪心- [洛谷 P1106]删数问题","slug":"blog7","date":"2018-08-17T06:17:53.000Z","updated":"2018-08-17T06:58:58.381Z","comments":true,"path":"2018/08/17/blog7/","link":"","permalink":"http://yoursite.com/2018/08/17/blog7/","excerpt":"","text":"描述键盘输入一个高精度的正整数 $N$，去掉其中任意 $k$ 个数字后剩下的数字按原左右次序将组成一个新的正整数。编程对给定的 $N$ 和 $k$ ，寻找一种方案使得剩下的数字组成的新数最小。 输出应包括所去掉的数字的位置和组成的新的整数。（ $N$ 不超过 $250$ 位） 输入数据均不需判错。 输入$n$(高精度的正整数) $k$(需要删除的数字个数) 输出最后剩下的最小数。 样例输入175438 4 样例输出13 这道题是贪心算法经典问题，思路：每次都选取一个使得剩下的数最小的数字。 注意：每次都选取最大的数字是错误的！ 我因为这个错了五次 废话不多说，代码简单易懂，直接上代码：12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;int main()&#123; char a[260],b[260],k[260]; int p; scanf(\"%s\",a); cin&gt;&gt;p; while(p&gt;=1)&#123; for(int i=0;i&lt;strlen(a);i++)&#123; strcpy(k,a); for(int j=i;j&lt;strlen(a);j++)&#123; k[j]=k[j+1]; &#125; int j=0; int d; sscanf(k,\"%d\",&amp;d); if(d!=0)&#123; while(k[j]=='0')&#123; for(int t=j;t&lt;strlen(a)-1;t++)&#123; k[t]=k[t+1]; &#125; j++; &#125; &#125; if(i==0) &#123; strcpy(b,k); continue; &#125; if(strlen(b)&gt;strlen(k)) &#123; strcpy(b,k); continue; &#125; if(strcmp(b,k)&gt;0)&#123; strcpy(b,k); &#125; &#125; strcpy(a,b); p--; &#125; cout&lt;&lt;a;&#125;","categories":[],"tags":[{"name":"洛谷","slug":"洛谷","permalink":"http://yoursite.com/tags/洛谷/"},{"name":"贪心","slug":"贪心","permalink":"http://yoursite.com/tags/贪心/"}]},{"title":"-其它-对拍模板","slug":"blog6","date":"2018-08-17T06:16:23.000Z","updated":"2018-08-17T06:28:36.766Z","comments":true,"path":"2018/08/17/blog6/","link":"","permalink":"http://yoursite.com/2018/08/17/blog6/","excerpt":"","text":"1234567891011121314151617#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; while(1) &#123; system(\"data &gt; input.txt\"); system(\"a+b &lt; input.txt &gt; 1.out\"); system(\"test &lt; input.txt &gt; 2.out\"); if(system(\"fc 1.out 2.out\")) &#123; system(\"pause\"); break; &#125; &#125; return 0;&#125; 在找不出自己的输出有什么问题的情况下，可使用这个对拍程序","categories":[],"tags":[{"name":"其它","slug":"其它","permalink":"http://yoursite.com/tags/其它/"}]},{"title":"-数论-重要公式整理","slug":"blog5","date":"2018-08-17T06:12:49.000Z","updated":"2018-08-17T06:30:51.117Z","comments":true,"path":"2018/08/17/blog5/","link":"","permalink":"http://yoursite.com/2018/08/17/blog5/","excerpt":"","text":"1、\\sum_{i=1}^n {2i-1} = i^2 2、\\sum_{i=1}^n {i(i+1)} =\\frac {n(n+1)(n+2)}{3} 3、\\sum_{i=1}^n {i^2(i-1)!} = (n+1)!+1 4、\\sum_{i=1}^n {i^2} =\\frac {n(n+1)(2n+1)}{6} 5、\\sum_{i=1}^n {i^3} = (\\frac{i(i+1)}{2})^2","categories":[],"tags":[{"name":"数论","slug":"数论","permalink":"http://yoursite.com/tags/数论/"}]},{"title":"-数论-质数唯一分解定理","slug":"blog4","date":"2018-08-17T06:06:43.000Z","updated":"2018-08-17T06:28:35.460Z","comments":true,"path":"2018/08/17/blog4/","link":"","permalink":"http://yoursite.com/2018/08/17/blog4/","excerpt":"","text":"这有一个非常重要的公式： $\\prod_{i=1}^n p_i^{a_i}$ 其中 p_i 为质因数，a_i 为每个质因数的指数","categories":[],"tags":[{"name":"数论","slug":"数论","permalink":"http://yoursite.com/tags/数论/"}]},{"title":"-数论-线性筛素数","slug":"blog3","date":"2018-08-17T05:43:24.000Z","updated":"2018-08-17T06:28:38.508Z","comments":true,"path":"2018/08/17/blog3/","link":"","permalink":"http://yoursite.com/2018/08/17/blog3/","excerpt":"","text":"在C++中，筛素数是一个非常重要算法。 我花了半天时间才明白的欧拉筛（我实在是太蒻了）。 最愚蠢的方法： 123456789101112#include&lt;cstdio&gt;int main()&#123; int n,k; scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++)&#123; if(n%i==0)&#123; printf(\"yes\"); return 0; &#125; &#125; printf(\"no\");&#125; 普通方法：123456789101112#include&lt;cstdio&gt;int main()&#123; int n,k; scanf(\"%d\",&amp;n); for(int i=1;i&lt;=sqrt(n);i++)&#123; if(n%i==0)&#123; printf(\"yes\"); return 0; &#125; &#125; printf(\"no\");&#125; 以上两种方法其实都是判定方法，并不是筛法，下面说真正的筛法： 1.埃筛法：12345678910111213141516#include&lt;iostream&gt;using namespace std;int main()&#123; int i,j,n,flag=1; bool a[100]=&#123;0&#125;; for(i=1;i&lt;=100;i++)&#123; for(j=2;j&lt;=100;j++)&#123; a[i*j]=1; &#125; &#125; for(int p=0;p&lt;=100;p++) if(a[p]==0)&#123; cout&lt;&lt;a[p]&lt;&lt;\" \"; &#125; return 0;&#125; 思路：首先将所有2的倍数标为1，再将所有3的倍数标为1……以此类推。 2.欧拉筛： 123456789101112131415#define MAXN 1000000int main()&#123; int chk[MAXN]=&#123;0&#125;; int p[MAXN]=&#123;0&#125;; int t=0; 6 for (int i=2;i&lt;MAXN;i++)&#123; if (!chk[i]) p[t++]=i; for (int j=0;j&lt;t&amp;&amp; i*p[j]&lt;MAXN;j++) &#123; chk[i*p[j]] = 1; if (i%p[j]==0) break; &#125; &#125;&#125; 思路：由于埃筛法做了许多不必要的循环，所以欧拉筛在埃筛法的基础上，省去了一些步骤，时间复杂度$O(n)$。","categories":[],"tags":[{"name":"数论","slug":"数论","permalink":"http://yoursite.com/tags/数论/"}]},{"title":"-其它-名字竞技场","slug":"blog2","date":"2018-08-17T05:41:31.000Z","updated":"2018-08-17T06:05:24.611Z","comments":true,"path":"2018/08/17/blog2/","link":"","permalink":"http://yoursite.com/2018/08/17/blog2/","excerpt":"","text":"自己写的，dalao勿喷 V1.1 有了名字判重系统，以及可以循环玩游戏了！ V1.2 可以多人玩游戏了！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include&lt;bits/stdc++.h&gt;#include&lt;windows.h&gt;using namespace std;struct note&#123; char a[10]; int hp; int gj;&#125;;note player[16];int hit1,hit2,g[11],pdh1=0,pdh2=0,n;void shuru();void gj();void youxi();void slowsay(char a[])&#123; for(int i=0;i&lt;strlen(a);i++)&#123; cout&lt;&lt;a[i]; Sleep(25); &#125;&#125;int main()&#123; srand((unsigned)time(NULL)); slowsay(\"欢迎来到名字竞技场！ by Steve_bm\"); cout&lt;&lt;endl; slowsay(\"V 1.2\"); cout&lt;&lt;endl; cout&lt;&lt;\"请输入人数：\"; cin&gt;&gt;n; shuru(); youxi(); return 0;&#125;void gj()&#123; int op1,op2; op1=rand()%n+1; op2=rand()%n+1; if((op1==op2)||(player[op1].hp==0||player[op2].hp==0))&#123; while(1)&#123; op1=rand()%n+1; op2=rand()%n+1; if((op1!=op2)&amp;&amp;(player[op1].hp!=0&amp;&amp;player[op2].hp!=0)) break; &#125; &#125; hit1=rand()%player[op1].gj+1; player[op2].hp-=hit1; if(player[op2].hp&lt;=0) player[op2].hp=0; cout&lt;&lt;player[op1].a&lt;&lt;\"对\"&lt;&lt;player[op2].a&lt;&lt;\"发起了攻击\"&lt;&lt;endl; Sleep(500); if(hit1&gt;=((player[op1].gj/3)*2)) cout&lt;&lt;player[op1].a&lt;&lt;\"暴击！\"&lt;&lt;endl; cout&lt;&lt;player[op2].a&lt;&lt;\"受到了\"&lt;&lt;hit1&lt;&lt;\"点伤害\"&lt;&lt;endl; Sleep(250); cout&lt;&lt;player[op2].a&lt;&lt;\"现在的生命值是\"&lt;&lt;player[op2].hp&lt;&lt;endl; cout&lt;&lt;endl;&#125;void youxi()&#123; Sleep(1200); for(int t=1;t&lt;=n;t++)&#123; int n1=player[t].a[0]+200; int q1=player[t].a[strlen(player[t].a)-1]; player[t].hp=(rand()%n1+30)*9; player[t].gj=(rand()%q1+30)*7; &#125; system(\"cls\"); for(int b=1;b&lt;=n;b++)&#123; cout&lt;&lt;player[b].a&lt;&lt;\" \"&lt;&lt;\"HP:\"&lt;&lt;player[b].hp&lt;&lt;\" \"&lt;&lt;\"攻击力:\"&lt;&lt;player[b].gj&lt;&lt;endl; cout&lt;&lt;endl; &#125; cout&lt;&lt;endl; Sleep(3000); cout&lt;&lt;\"现在开始!\"&lt;&lt;endl; Sleep(1500); int w; int f=0; while(1)&#123; gj(); Sleep(1000); cout&lt;&lt;endl; for(int i=1;i&lt;=n;i++)&#123; if(player[i].hp==0) f++; if(player[i].hp&gt;0) w=i; &#125; if(f==n-1) break; f=0; &#125; Sleep(1500); cout&lt;&lt;\"胜利者是\"; cout&lt;&lt;player[w].a&lt;&lt;\"!\"&lt;&lt;endl; for(int m=1;m&lt;=n;m++)&#123; if(player[m].hp==0)&#123; cout&lt;&lt;player[m].a&lt;&lt;\"完败!\"&lt;&lt;endl; &#125; &#125; char l; Sleep(3000); cout&lt;&lt;\"Do you want to play again?(Y/N)\"&lt;&lt;endl; cin&gt;&gt;l; if(l=='Y'||l=='y')&#123; system(\"cls\"); for(int h=1;h&lt;=n;h++)&#123; memset(player[h].a,0,sizeof(player[h].a)); &#125; youxi(); &#125; else&#123; exit(0); &#125;&#125;void shuru()&#123; for(int l=1;l&lt;=n;l++)&#123; cout&lt;&lt;\"请输入玩家\"&lt;&lt;l&lt;&lt;\"的名字（名字不超过10字符，最小3字符，不能有汉字!）：\"&lt;&lt;endl; scanf(\"%s\",player[l].a); &#125; int yy[11]=&#123;0&#125;; for(int i=1;i&lt;n;i++)&#123; for(int o=i+1;o&lt;=n;o++)&#123; for(int q=0;q&lt;strlen(player[i].a);q++)&#123; if(player[i].a[q]==player[o].a[q]) yy[i]++; &#125; &#125; &#125; for(int u=1;u&lt;=n;u++)&#123; if(yy[u]==strlen(player[u].a))&#123; system(\"cls\"); cout&lt;&lt;\"输入的名字不能相同！\"&lt;&lt;endl; Sleep(100); cout&lt;&lt;\"请重新输入！\"&lt;&lt;endl; shuru(); &#125; else youxi(); &#125;&#125;","categories":[],"tags":[{"name":"其它","slug":"其它","permalink":"http://yoursite.com/tags/其它/"}]},{"title":"-置顶-新家","slug":"blog1","date":"2018-08-17T05:31:48.000Z","updated":"2018-08-17T07:38:08.207Z","comments":true,"path":"2018/08/17/blog1/","link":"","permalink":"http://yoursite.com/2018/08/17/blog1/","excerpt":"","text":"我从cnblog那里搬过来的。 旧博客。","categories":[],"tags":[]}]}